#$%2$%#
def bubble_sort(lst):
    n = len(lst)
    for i in range(n):
        for j in range(0, n-i-1):
            if lst[j] > lst[j+1] :
                lst[j], lst[j+1] = lst[j+1], lst[j]
    return lst

#$%3$%#
def quick_sort(lst):
    if len(lst) <= 1:
        return lst
    pivot = lst[len(lst) // 2]
    left = [x for x in lst if x < pivot]
    middle = [x for x in lst if x == pivot]
    right = [x for x in lst if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

#$%6$%#
def selection_sort(lst):
    for i in range(len(lst)):
        min_idx = i
        for j in range(i+1, len(lst)):
            if lst[min_idx] > lst[j]:
                min_idx = j
        lst[i], lst[min_idx] = lst[min_idx], lst[i]
    return lst

#$%15$%#
def cycle_sort(lst):
    writes = 0
    for cycleStart in range(0, len(lst) - 1):
        item = lst[cycleStart]
        pos = cycleStart
        for i in range(cycleStart + 1, len(lst)):
            if lst[i] < item:
                pos += 1
        if pos == cycleStart:
            continue
        while item == lst[pos]:
            pos += 1
        lst[pos], item = item, lst[pos]
        writes += 1
        while pos != cycleStart:
            pos = cycleStart
            for i in range(cycleStart + 1, len(lst)):
                if lst[i] < item:
                    pos += 1
            while item == lst[pos]:
                pos += 1
            lst[pos], item = item, lst[pos]
            writes += 1
    return lst

#$%22$%#
def tree_sort(lst):
    from bst import BST
    bst = BST()
    for el in lst:
        bst.insert(el)
    return bst.inorder()

#$%23$%#
def tim_sort(lst):
    from timsort import TimSort
    ts = TimSort(lst)
    ts.sort()
    return lst

#$%26$%#
def patience_sort(lst):
    import bisect
    piles = []
    for x in lst:
        new_pile = [x]
        i = bisect.bisect_left(piles, new_pile)
        if i != len(piles):
            piles[i].insert(0, x)
        else:
            piles.append(new_pile)
    for i in range(len(lst)):
        small_pile = piles[0]
        for j in range(1, len(piles)):
            if piles[j][0] < small_pile[0]:
                small_pile = piles[j]
        lst[i] = small_pile.pop(0)
        if small_pile == []:
            piles.remove(small_pile)
    return lst

#$%28$%#
def spaghetti_sort(lst):
    max_val = max(lst)
    length = len(lst)
    ptr = [0] * length
    for i in range(length):
        ptr[i] = lst[i]
    ptr.sort()
    return ptr

#$%29$%#
def gravity_sort(lst):
    max_val = max(lst)
    beads = [0] * len(lst) * max_val
    for i in range(len(lst)):
        for j in range(lst[i]):
            beads[i + j * len(lst)] = 1
    for i in range(len(lst), len(beads)):
        if beads[i] == 1:
            beads[i - len(lst)], beads[i] = beads[i], beads[i - len(lst)]
    for i in range(len(lst)):
        lst[i] = sum(beads[i::len(lst)])
    return lst

#$%30$%#
def cocktail_shaker_sort(lst):
    for i in range(len(lst)-1, 0, -1):
        swapped = False
        for j in range(i, 0, -1):
            if lst[j] < lst[j-1]:
                lst[j], lst[j-1] = lst[j-1], lst[j]
                swapped = True
        for j in range(i):
            if lst[j] > lst[j+1]:
                lst[j], lst[j+1] = lst[j+1], lst[j]
                swapped = True
        if not swapped:
            return lst

#$%32$%#
def pigeonhole_sort(lst):
    min_val = min(lst)
    max_val = max(lst)
    size = max_val - min_val + 1
    holes = [0] * size
    for x in lst:
        assert type(x) is int, "integers only please"
        holes[x - min_val] += 1
    i = 0
    for count in range(size):
        while holes[count] > 0:
            holes[count] -= 1
            lst[i] = count + min_val
            i += 1
    return lst

#$%34$%#
def gnome_sort(lst):
    pos = 0
    while pos < len(lst):
        if (pos == 0 or lst[pos] >= lst[pos - 1]):
            pos = pos + 1
        else:
            lst[pos], lst[pos - 1] = lst[pos - 1], lst[pos]
            pos = pos - 1
    return lst

#$%36$%#
def pancake_sort(lst):
    cur = len(lst)
    while cur > 1:
        mi = lst.index(max(lst[0:cur]))
        lst = lst[mi::-1] + lst[mi+1:len(lst)]
        lst = lst[cur-1::-1] + lst[cur:len(lst)]
        cur -= 1
    return lst

#$%38$%#
def bead_sort(lst):
    if all([type(x) == int and x >= 0 for x in lst]):
        return sorted(lst)
    else:
        raise ValueError("List elements must be positive integers")

#$%39$%#
def bucket_sort(lst):
    if len(lst) == 0:
        return lst
    min_val = min(lst)
    max_val = max(lst)
    bucket_range = (max_val-min_val) / len(lst)
    count_list = [0]*(len(lst)+1)
    for num in lst:
        count_list[int((num-min_val)//bucket_range)] += 1
    sorted_list = []
    for i in range(len(count_list)):
        if count_list[i] != 0:
            sorted_list += [i*bucket_range + min_val]*count_list[i]
    return sorted_list

#$%40$%#
def radix_sort(lst):
    RADIX = 10
    maxLength = False
    tmp, placement = -1, 1
    while not maxLength:
        maxLength = True
        buckets = [list() for _ in range(RADIX)]
        for i in lst:
            tmp = i // placement
            buckets[tmp % RADIX].append(i)
            if maxLength and tmp > 0:
                maxLength = False
        a = 0
        for b in range(RADIX):
            buck = buckets[b]
            for i in buck:
                lst[a] = i
                a += 1
        placement *= RADIX
    return lst

#$%41$%#
def counting_sort(lst):
    max_val = max(lst)
    m = max_val + 1
    count = [0] * m                
    for a in lst:
        count[a] += 1             
    i = 0
    for a in range(m):            
        for c in range(count[a]):  
            lst[i] = a
            i += 1
    return lst

#$%43$%#
def shell_sort(lst):
    gap = len(lst) // 2
    while gap > 0:
        for i in range(gap, len(lst)):
            temp = lst[i]
            j = i
            while  j >= gap and lst[j-gap] >temp:
                lst[j] = lst[j-gap]
                j -= gap
            lst[j] = temp
        gap //= 2
    return lst

#$%45$%#
def insertion_sort(lst):
    for i in range(1, len(lst)):
        key = lst[i]
        j = i-1
        while j >=0 and key < lst[j] :
                lst[j+1] = lst[j]
                j -= 1
        lst[j+1] = key
    return lst

#$%46$%#
def merge_sort(lst):
    if len(lst) <= 1:
        return lst
    mid = len(lst) // 2
    left = lst[:mid]
    right = lst[mid:]
    left = merge_sort(left)
    right = merge_sort(right)
    return list(merge(left, right))

#$%49$%#
def monte_carlo_pi(iterations):
    inside_circle = 0
    import random
    for _ in range(iterations):
        x, y = random.random(), random.random()
        if x**2 + y**2 <= 1:
            inside_circle += 1
    return inside_circle

#$%50$%#
def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)

#$%51$%#
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)


#$%53$%#
def sieve_of_eratosthenes(n):
    primes = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (primes[p] == True):
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    prime_numbers = [p for p in range(2, n) if primes[p]]
    return prime_numbers